## January 13th
### Function of a Compiler
A compiler needs a source and target program  
The translation of a programming language is split into two
parts  
 - Syntax (the structure of sentences in the language)
 - Semantics (the meaning of sentences in the language)  

### Syntactic description of a language
A simple CFG describes a few English sentences  
Sentence ::= Subject Predicate Object  
Subject ::= Article Noun
Predicate ::= Verb  
Object := Article Noun  
Article ::= a | the  
Noun ::= dog | cat | mice  
Verb ::= chase | chases  

Components:
1. Terminals - a, the, dog, cat, mice, chase, chases
2. Nonterminals - Sentence, Subject, Predicate, Article,
   Noun, Verb
3. Start nonterminal - Sentence
4. Rules - (Shown above)  

The *Language* generated by a CFG is a set of the possible
sentences  

CFGs describe a superset of meaningful sentences, and will
include grammatically incorrect sentences in the languages
they generate  
We need additional constraints to determine validity  

CFGs can be used to find the **structure of a sentence**  
A parser is used to find the syntax tree for a sentence  
The syntax tree describes the sentence structure  

CFGs for programming languages ensure a unique syntax tree
for each sentence (no ambiguous grammars)  
They can also be efficiently parsed (not all CFGs can be
efficiently parsed)  

### A CFG for a Programming Language
**Expressions in Mini-Triangle:**  
*Exp* ::= PrimExp | Exp Oper PrimExp  
PrimExp ::= intlit | id | Oper PrimExp | (Exp)  
Oper ::= + | - | * | / | < | > | =  

**Special interpretation of terminals:**  
intlit stands for any integer  
id stands for any identifier  
blanks are ignored  

**Syntax Tree Examples:**  
```
-20:
Exp => PrimExp => Oper PrimExp => - PrimExp => - intlit => -20

x + y:
Exp => Exp Oper PrimExp => PrimExp Oper PrimExp => id Oper PrimExp => x Oper PrimExp => x + PrimExp => x + id => x + y

x - y > 0:
Exp => Exp Oper PrimExp => Exp Oper PrimExp Oper PrimExp => PrimExp Oper PrimExp Oper PrimExp => id Oper id Oper intlit => x - y > 0
```

The problem with syntax trees is that they have unnecessary
detail and the derivations interfere with utility  
**Abstract Syntax Trees** are a better representation of the
"meaning" of a program  

**Abstract Structure of Expressions:**  
Exp :== intlit | id | op Exp | Exp op Exp  
op Exp is called a unop and Exp op Exp is a binop  

They cannot be used alone to parse because they are inherently
ambiguous. However, they make understanding a language
simpler.  

```
CFG for mini-Triangle:
Program ::= Cmd
Cmd     ::= id := Exp | let Decl in Cmd
Decl    ::= var id : type

Abstract syntax tree for mini-Triangle:
Cmd ::= id type Cmd   (declaration - decl)
      | id Exp      (assignment - assign)
```

Formally, Syntax => Context free grammar with additional
lexical rules (comments, whitespace, etc)  
Additional Contextual Constraints (can be made formal)  
Identifier declaration and reference rules plus type rules  
Semantics => Operational definition of evaluation  

### Phases of Compilation
Lexical Analysis (scanner) - Character stream => tokens  
Syntactic Analysis (parser) - tokens => AST  
Contextual Analysis (type checking/identifier resolution)
- AST => decorated AST  
Optimization (optional) - decorated AST => decorated AST  
Code Generation - decorated AST => machine instructions  
